1.箭头函数和普通函数
    普通函数通过function定义，this只能在运行时绑定，取决于调用者
    箭头函数可以让this指向固化，但是箭头函数本身没有this，箭头函数所谓的this其实是外部代码块的this
    箭头函数没有原型，没有this，没有super等，没有construct方法，不能被当作构造函数用，没有arguments
2.static关键字
    为一个class直接添加静态方法，该方法只能通过类调用，不能通过实例调用
3.event loop
    事件循环是浏览器为了解决js单线程运行时不会长久阻塞的一种机制
    事件循环是消息队列进行的，队列维护了宏任务，每一个宏任务下有一个微任务队列，当前宏任务执行完会执行微任务队列，结束之后开启下一轮事件循环
    常见的宏任务：setTimeOut/ I/O /UI render/setInterval/script
    常见的微任务：process.nextTick()/Promise
4.new一个对象发生了什么
    创建一个空对象
    将空对象的prototype链接到构造函数的__proto__
    为新对象绑定函数的this，并将参数传入
    如果函数没有返回其他对象，new一个实例的时候将会返回这个新对象
    ```js
    function myNew(){
        const o = new Object();
        const FunctionConstructor = [].shift.call(arguments);//拿到构造函数
        o.__proto__ = FunctionConstructor.prototype;//绑定原型

        const res = FunctionConstructor.apply(o,arguments);
        return typeof res === 'object' ? res : o;
    }

    function Player(name){
        this.name = name;
    }

    const p = myNew(Player,"hhhhhh");
    console.log(p);
    ```
5.闭包
    https://segmentfault.com/a/1190000012646221
6.call apply bind
    都是用来显式改变this指向的，第一个参数都是需要为this绑定的值
    call的第一个参数之后是正常参数，apply的第一个参数之后是数组，bind的第一个参数之后是数组
    call和apply都是立即执行，bind不会立即执行，而是返回一个改变了上下文this后的函数，以便后续调用
    绑定优先级：new绑定 > 显式绑定 > 隐式绑定 > 默认绑定
7.如何判断一个对象是不是空对象
    JSON.stringify(obj) === "{}"
    Object.getKeys(obj).length === 0
    Object.getOwnPropertyNames(obj).length === 0
8.判断是否是一个对象
    Object.prototype.toString.call(obj) === "[object object]"
    obj.constructor === Object
    obj instanceof object  该方法数组也会返回true
    typeof同上
9.继承方式
    原型链继承：
    ```js
    function SuperType() {
        this.property = true;
    }

    SuperType.prototype.getSuperValue = function() {
        return this.property;
    }

    function SubType() {
        this.subproperty = false;
    }

    // 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype
    SubType.prototype = new SuperType(); 

    SubType.prototype.getSubValue = function() {
        return this.subproperty;
    }

    var instance = new SubType();
    console.log(instance.getSuperValue()); // true
    ```
