## 优先级

`状态更新`由`用户交互`产生，用户心里对`交互`执行顺序有个预期。`React`根据`人机交互研究的结果`中用户对`交互`的预期顺序为`交互`产生的`状态更新`赋予不同优先级。

具体如下：

- 生命周期方法：同步执行。
- 受控的用户输入：比如输入框内输入文字，同步执行。
- 交互事件：比如动画，高优先级执行。
- 其他：比如数据请求，低优先级执行

**如何调度优先级？**

react通过Scheduler调度任务，每当任务需要调度时，react会调用Scheduler提供的方法runWithPriority，该方法接收一个`优先级`常量与一个`回调函数`作为参数。`回调函数`会以`优先级`高低为顺序排列在一个`定时器`中并在合适的时间触发

例子：

![image-20220509214243989](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220509214243989.png)

在这个例子中，将“关闭黑夜模式”作为u1,用户输入作为u2

其中u1先触发并进入render阶段

```js
fiber.updateQueue = {
  baseState: {
    blackTheme: true,
    text: 'H'
  },
  firstBaseUpdate: null,
  lastBaseUpdate: null
  shared: {
    pending: u1
  },
  effects: null
};
```

此时，由于u2属于用户输入，优先级高于u1，所以u1的render中断

```js
fiber.updateQueue.shared.pending = u2 --->  u1
                                   ^        |
                                   |________|
//即
u2.next = u1;
u1.next = u2;
```

接下来会进入u2的render阶段

因为shared.pending始终指向最后一个，所以此时的执行顺序为u1 --- u2,此时环状链表被剪开，拼接到baseUpdate后面

然后遍历baseUpdate，u1因为优先级不够被跳过，u2最终完成render--commit

此时：

```js
fiber.updateQueue = {
  baseState: {
    blackTheme: true,
    text: 'HI'
  },
  firstBaseUpdate: u1,
  lastBaseUpdate: u2
  shared: {
    pending: null
  },
  effects: null
};
```

在`commit`阶段结尾会再调度一次更新。在该次更新中会基于`baseState`中`firstBaseUpdate`保存的`u1`，开启一次新的`render阶段`。

最终两次`Update`都完成后的结果如下：

```js
fiber.updateQueue = {
  baseState: {
    blackTheme: false,
    text: 'HI'
  },
  firstBaseUpdate: null,
  lastBaseUpdate: null
  shared: {
    pending: null
  },
  effects: null
};
```

### 如何保证update不丢失？

在render阶段，shared.pending会被剪开，实际上剪开后的shared.pending会被拼接到workInProgress updateQueue.lastBaseUpdate上和current updateQueue.lastBaseUpdate上

当render阶段被中断后，会基于current updateQueue克隆出workInProgress updateQueue,由于current updateQueue.lastBaseUpdate已经保存了上一次的Update，所以不会丢失

当`commit阶段`完成渲染，由于`workInProgress updateQueue.lastBaseUpdate`中保存了上一次的`Update`，所以 `workInProgress Fiber树`变成`current Fiber树`后也不会造成`Update`丢失

### 如何保证状态依赖的连续性？

当某个`Update`由于优先级低而被跳过时，保存在`baseUpdate`中的不仅是该`Update`，还包括链表中该`Update`之后的所有`Update`