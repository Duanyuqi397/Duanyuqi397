## 箭头函数和普通函数

​    普通函数通过function定义，this只能在运行时绑定，取决于调用者
​    箭头函数可以让this指向固化，但是箭头函数本身没有this，箭头函数所谓的this其实是外部代码块的this
​    箭头函数没有原型，没有this，没有super等，没有construct方法，不能被当作构造函数用，没有arguments

## 原型和原型链

原型链就是一个过程，原型就是这个过程中的一个单位

每一个引用类型都有一个隐式原型对象`__proto__`，这个隐式原型指向他的构造函数的显式原型prototype属性值，当使用一个对象的某个属性时，如果这个对象上没有，就会顺着`__proto__`（也就是构造函数的prototype）去寻找

![image-20220530171958459](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220530171958459.png)

## call,apply,bind

共同点：都是通过改变函数的执行上下文来改变this指向，使一个对象上的方法可以通过另一个对象来调用

不同点：

1. 参数上：第一个参数都是需要绑定到的对象，call从第二个参数开始可以接收很多个，并且都会被绑定到对象上，apply和bind的第二个参数是一个数组或者类数组
2. 调用上：call和apply都是立即调用，而bind方法的返回值是一个函数，需要稍后调用才会执行

## static关键字

​    为一个class直接添加静态方法，该方法只能通过类调用，不能通过实例调用

## event loop

​    事件循环是浏览器为了解决js单线程运行时不会长久阻塞的一种机制
​    事件循环是消息队列进行的，队列维护了宏任务，每一个宏任务下有一个微任务队列，当前宏任务执行完会执行微任务队列，结束之后开启下一轮事件循环
​    常见的宏任务：setTimeOut/ I/O /UI render/setInterval/script
​    常见的微任务：process.nextTick()/Promise

## new一个对象发生了什么

​    创建一个空对象
​    将空对象的prototype链接到构造函数的__proto__
​    为新对象绑定函数的this，并将参数传入
​    如果函数没有返回其他对象，new一个实例的时候将会返回这个新对象

    ```js
    function myNew(){
        const o = new Object();
        const FunctionConstructor = [].shift.call(arguments);//拿到构造函数
        o.__proto__ = FunctionConstructor.prototype;//绑定原型
    ```
    
        const res = FunctionConstructor.apply(o,arguments);
        return typeof res === 'object' ? res : o;
    }
    
    function Player(name){
        this.name = name;
    }
    
    const p = myNew(Player,"hhhhhh");
    console.log(p);
    ```
## 闭包

​    https://segmentfault.com/a/1190000012646221

## call apply bind

​    都是用来显式改变this指向的，第一个参数都是需要为this绑定的值
​    call的第一个参数之后是正常参数，apply的第一个参数之后是数组，bind的第一个参数之后是数组
​    call和apply都是立即执行，bind不会立即执行，而是返回一个改变了上下文this后的函数，以便后续调用
​    绑定优先级：new绑定 > 显式绑定 > 隐式绑定 > 默认绑定

## 如何判断一个对象是不是空对象

​    JSON.stringify(obj) === "{}"
​    Object.getKeys(obj).length === 0
​    Object.getOwnPropertyNames(obj).length === 0

## 判断是否是一个对象

​    Object.prototype.toString.call(obj) === "[object object]"
​    obj.constructor === Object
​    obj instanceof object  该方法数组也会返回true
​    typeof同上

## 继承方式

###     原型链继承

​    ```js
​    function SuperType() {
​        this.property = true;
​    }

    SuperType.prototype.getSuperValue = function() {
        return this.property;
    }
    
    function SubType() {
        this.subproperty = false;
    }
    
    // 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype
    SubType.prototype = new SuperType(); 
    
    SubType.prototype.getSubValue = function() {
        return this.subproperty;
    }
    
    var instance = new SubType();
    console.log(instance.getSuperValue()); // true
    ```
## 深浅拷贝

​    浅拷贝：创建一个新对象，这个对象有原始对象的数据的一份精确拷贝，基本类型：拷贝值，引用类型：拷贝内存地址，其中一个对象改变了地址，就会影响到别的对象
​    深拷贝：将原始对象从内存中完整的拷贝一份，开辟一个新的地址来进行存放
​    实现浅拷贝的方式：
​        Object.assign()
​        扩展运算符 ...
​        Array.prototype.concat()
​        Array.prototype.slice()
​    实现深拷贝的方式：
​        JSON.parse(JSON.stringify()),不能处理函数和正则
​        递归处理

## string是否有最大长度

string用于表示文本数据，最大长度是2^53-1,最大长度不是表示字符数，而是string通过UTF16编码后的长度，string的意义也并不是字符串，而是字符串的UTF16编码

## 0.1 + 0.2 === 0.3 是false

根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数，

所以非整数的Number类型也不能通过==或者===来进行比较，**正确的比较方法是：**

```js
console.log( Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);
```

通过绝对值差值是否小于最小精度来比较浮点数，才是正确方法

## JS中的对象分类

### 宿主对象

最熟悉的宿主对象就是浏览器对象window，window上又有很多属性，比如document，全局对象window上的属性**一部分来自浏览器环境，一部分来自JavaScript**

### 内置对象

由js语言提供的对象

#### 固有对象

固有对象由标准规定，随着JS运行时创建而自动创建的对象，固有对象在JS运行前就创建出来了，通常扮演类似基础库的角色

#### 原生对象

能够通过语言本身的构造器创建的对象称为原生对象，JS里面有30多个构造器

![image-20220526160710230](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220526160710230.png)

通过这些构造器，可以直接使用new来创建新的对象，所以这些对象称为原生对象

#### 普通对象

由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承

### 用对象来模拟函数和构造器：函数对象与构造器对象

**函数对象：具有[[call]]私有字段的对象，构造器对象：具有[[construct]]私有字段的对象**

可以这样理解：任何对象，只要实现了call，那它就是函数对象；实现了construct，那他就是构造器对象

### 现在要实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色

```js
function slepp(duration){
    return new Promise(function(resovle){
        setTimeout(resolve,duration);
    })
}

async function changeColor(duration,color){
    document.getElementById("traffic-light").style.color = color;
    await sleep(duration);
}

async funtion main(){
    while(1){
        await changeColor(3,"green");
        await changeColor(1,"yellow");
        await changeColor(2,"red");
    }
}

main();
```

## 闭包和执行上下文

### 闭包

闭包本质上只是一个**绑定了执行环境的函数**

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包

### 执行上下文

JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”

JavaScript 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表，当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈

## Completion类型

例子：

```js
function foo(){
    try{
        return 0;
    } catch (err) {
        
    } finally {
        console.log(1);
    }
}
console.log(foo());//1
```

这个例子中，按照常规思维来讲，try的时候就会return掉，但是最终执行结果是打印了1，也return 了 0

如果在finally中再return一下：

```js
function foo(){
    try{
        return 0;
    } catch (err) {
        
    } finally {
        return 1;
    }
}
console.log(foo());//1
```

结果是return了1，也就是finally覆盖了try里面的return

在这背后，运行的机制是JavaScript语句执行的完成状态，用一个标准类型来描述就是：**Completion Record**

Completion Record表示一个语句执行之后的结果，它有三个字段：

- [[type]]：表示完成的类型，例如return,break,continue,throw和normal几种类型
- [[value]]：表示语句执行之后的返回值，如果没有返回值，为empty
- [[target]]：表示语句的目标，通常是一个JavaScript标签

JavaScript 正是依靠语句的 Completion Record 类型，方才可以在语句的复杂嵌套结构中，实现各种控制

语句的分类：

![image-20220526173851377](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220526173851377.png)

### 

### 普通语句

普通语句按顺序执行，执行后会得到type为normal的Completion Record，js引擎遇到这种类型的Completion Record会继续执行

这些语句中，只有表达式语句会生成value

![image-20220526174200694](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220526174200694.png)

Chrome 控制台显示的正是语句的 Completion Record 的[[value]]

### 语句块

语句块就是用{}包起来的语句

需要注意的是语句块内部的语句的 Completion Record 的[[type]] 如果不为 normal，会打断语句块后续的语句执行

例如：

```js
{
  var i = 1; // normal, empty, empty
  return i; // return, 1, empty
  i ++; 
  console.log(i)
} // return, 1, empty
```

在语句块中遇到了非normal的type，会将当前的Completion Record直接返回，整个语句块都会变成非normal，这个结构就保证了非 normal 的完成类型可以**穿透复杂的语句嵌套结构，产生控制效果**

### 控制型语句

控制类语句分成两部分，一类是对其内部造成影响，如 if、switch、while/for、try。

另一类是对外部造成影响如 break、continue、return、throw，这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果

![image-20220526174803613](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220526174803613.png)

通过这个表也就解释了最初的例子，因为 **finally 中的内容必须保证执行**，所以 try/catch 执行完毕，即使得到的结果是非 normal 型的完成记录，也必须要执行 finally。而当 finally 执行也得到了非 normal 记录，则会使 finally 中的记录作为整个 try 结构的结果

### 带标签的语句

任何 JavaScript 语句是可以加标签的，在语句前加冒号即可：

```js
firstStatement: var i = 1;
```

大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与完成记录类型中的 target 相配合，用于跳出多层循环

```js

    outer: while(true) {
      inner: while(true) {
          break outer;
      }
    }
    console.log("finished")
```

break/continue 语句如果后跟了关键字，会产生带 target 的完成记录。一旦完成记录带了 target，那么只有拥有对应 label 的循环语句会消费它
